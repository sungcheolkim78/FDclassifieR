---
title: "Tutoral"
author: "Sungcheol Kim"
date: "2/15/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(FDclassifieR)
```

## Generate sample classifer

```{r}
# generate labels
y <- generate.labels(N = 10000, rho=0.4)

# generate scores with a specific AUC from gaussian distribution
gs <- classifier.gaussian(y, auc=0.9, tol = 0.0001)
```

```{r}
g1 <- plot.scores(gs, y)
g1
```

## Sampling for class probability at given rank

```{r}
# N is a maximum rank, M is the number of sampling

pcr1 <- pcr(gs, y, N=400, M=400)
#plot(pcr1)
```

```{r}
print(pcr1)
```


```{r}
auclist <- c(0.7, 0.75, 0.8, 0.85, 0.9)
Mlist <- (2:6)*200
Nlist <- (1:5)*100

res <- data.table()
y <- generate.labels(N = 10000, rho=0.5)
  
for (a in auclist) {
  gs <- classifier.gaussian(y, auc=a, tol = 0.0001)
  for (N in Nlist) {
    for (M in Mlist) {
      pcr1 <- pcr(gs, y, N=N, M=M)
      t <- print(pcr1)
      res <- rbind(res, t)
    }
  }
}

#cp <- score.to.classprob(gc, N=200, M=200, debug.flag=T)
res
```

```{r}
ggplot(data=res[res$M == 400, ]) + geom_point(aes(x=N, y=auc_pcr/auc0, color=auc0)) + theme_classic()  
```

```{r}
ggplot(data=res) + geom_point(aes(x=M, y=auc_pcr, color=N)) + theme_classic() +
  geom_point(aes(x=M, y=auc_pxysum, color=N)) + geom_hline(yintercept = res$auc0[[1]])
```

```{r}
ggplot(data=res) + geom_point(aes(x=auc0, y=auc_pcr), color='black') + theme_classic() +
  geom_point(aes(x=auc_pcr, y=auc_pxysum), color='red') + geom_abline(slope=1) +
  geom_point(aes(x=auc_pcr, y=auc_pxysample), color='blue')
```

## Calculation AUC

To check $\Delta = <r|1> - <r|0>$, we can calculate $<r|1>$ and $<r|0>$ seperately. 

```{r}
rankprob <- cp

print(sum(rankprob$rank * rankprob$prob)/sum(rankprob$prob))
print(sum(rankprob$rank * (1 - rankprob$prob)/sum(1 - rankprob$prob)))
```

```{r}
sigma.rank(rankprob, debug.flag = T)
```

```{r}
auc.rank(rankprob)
```

```{r}
auprc.rank(rankprob)
```

```{r}
rankprob <- cal.fromRank(rankprob)
```

```{r}
plot.curves(rankprob)
```

Calculate Pxy by sampling two ranks from class 1 and class 2

```{r}
auc.Pxysample(rankprob, iter = 10000)
```

Calculate Pxy using summation over all possible conditions.

```{r}
auc.Pxysum(rankprob, debug.flag = T)
```

```{r}
library(pROC)
roc_test <- roc(y, gs)
auc(roc_test)
```

```{r}
plot(roc_test, xlim=c(1,0), ylim=c(0,1))
```

```{r}
plot.scores(gc)
```

## Confidence Interval

```{r}
Pxxy.sample(rankprob, iter=5000, debug.flag=T)
```

```{r}
Pxxy.sum(rankprob)
```

```{r}
Pxxy.sum2(rankprob)
```

```{r}
Pxyy.sample(rankprob, iter=5000, debug.flag=T)
```

```{r}
Pxyy.sum(rankprob)
```

```{r}
Pxyy.sum2(rankprob)
```


```{r}
var.auc(rankprob, debug.flag = T)
```

```{r}
ci(roc_test)
```

```{r}
var_auc_fermi(0.9, 100, 100, debug.flag = T)
```

```{r}
auc
```

```{r}
var_auc_fermi(0.895, 283, 25374, iter=8000, debug.flag = T)
```

```{r}
var_auc_fermi(0.942, 780, 67228, iter=10000, debug.flag = T)
```

```{r}
count <- 0
for (i in 1:10) {
  for (j in 1:10) {
    for (k in 1:10) {
      if (i < min(c(j, k))) {
        print(sprintf("(%d, %d, %d)", i, j, k))
        count <- count + 1
      }
    }
  }
}
print(count)
```

```{r}
count <- 0
m2 <- matrix(100, 10, 10)

for (i in 1:10) {
  idx <- (m2 > 0)
  idx[, 1:i] <- FALSE
  idx[1:i, ] <- FALSE
  diag(idx) <- FALSE
  
  print(idx)
  count <- count + sum(idx)
}
print(count)
```


# Ensemble method

```{r}
auclist <- generate.auclist(0.6, 0.8, 30)
data_rank <- create_predictions(n=1000, auclist=auclist, p=0.6)
```

```{r}
fde1 <- fde(data_rank$predictions, data_rank$actual_performance)
```

```{r}
#fde1 <- calculate_performance(fde1, data_rank$actual_labels)
fde1 <- predict_performance(fde1, auclist, 0.6)
```

```{r}
hist(fde1@estimated_rank)
```

```{r}
plot_FDstatistics(fde1)
```

```{r}
plot(fde1, "score", c=20)
```

```{r}
plot(fde1, "pcr", c=20, n=100, m=300)
```

```{r}
plot(fde1, "roc", c=20, n=100, m=300)
```

